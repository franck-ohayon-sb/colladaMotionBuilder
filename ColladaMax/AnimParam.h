/*
	Copyright (C) 2005-2007 Feeling Software Inc.
	Portions of the code are:
	Copyright (C) 2005-2007 Sony Computer Entertainment America
	
	MIT License: http://www.opensource.org/licenses/mit-license.php
*/
/*
	Based on the 3dsMax COLLADA Tools:
	Copyright (C) 2005-2006 Autodesk Media Entertainment
	MIT License: http://www.opensource.org/licenses/mit-license.php
*/

// Animation parameters grouping structure

#ifndef _ANIM_PARAM_H_
#define _ANIM_PARAM_H_

#include "strclass.h"
#include "PropertyMapper.h"

class IGameControl;
class PropertyMapper;
enum IGameControlType;

// animation library parameter bundle
//   set up and passed around by the various <animation> library utils 
class AnimParam 
{
public:
	TSTR objectID;			// object/node ID
	TSTR animID;			// animatable ID
	TSTR paramID;			// animatable param name
	IGameControl* c;
	IGameControlType type;
	PropertyMapper* mapper;	// value mapper if not NULL
	Tab<TSTR*> targets;		// channel targets
	Tab<TSTR*> subanims;	// subanim IDs
	int targetIndex;		// matrix index target: use -1 for none
	bool relative;

	AnimParam(const TSTR& _objectID) {
		objectID = _objectID;
		mapper = new IdentityMapper();
		targetIndex = -1;
		relative = false;
	}

	~AnimParam() { 
		clearTargets();
		clearSubanims();
		if (mapper != NULL) { delete mapper; mapper = NULL; }
	}

	TSTR getFullTarget(int subAnimIndex)
	{
		TSTR fullTarget;
		if (targetIndex < 0) fullTarget = objectID + TSTR(_T("/")) + (subAnimIndex < 0 ? paramID : *targets[subAnimIndex]);
		else
		{
			if (subAnimIndex < 0) fullTarget.printf("%s(%d)", objectID, targetIndex);
			else fullTarget.printf("%s(%d)%s", objectID, targetIndex, *targets[subAnimIndex]);
		}
		return fullTarget;
	}

	TSTR& getTarget(int subAnimIndex)
	{
		return subAnimIndex < 0 ? paramID : *targets[subAnimIndex];
	}

	TSTR& getSubanimID(int subAnimIndex) { return subAnimIndex < 0 ? animID : *subanims[subAnimIndex]; }

	AnimParam& setAnim(TCHAR* param, IGameControl* gc, IGameControlType gtype, int _targetIndex=-1) {
		targetIndex = _targetIndex;
		paramID = param; // don't clean this ID, it should ALWAYS be generated by the programmer
		animID = objectID + TSTR(_T("-")) + paramID;
		if (targetIndex != -1) animID.printf("%s_%d", animID.data(), targetIndex);
		c = gc;
		type = gtype;
		return *this;
	}

	AnimParam& setAnim(TCHAR* param, IGameControl* gc, IGameControlType gtype, Tab<const TCHAR*> _subanims, Tab<const TCHAR*> _targets, int _targetIndex=-1)
	{
		setAnim(param, gc, gtype, _targetIndex);
		setSubanims(_subanims);
		setTargets(_targets);
		return *this;
	}

	AnimParam& setAnim(TCHAR* param, IGameControl* gc, IGameControlType gtype, TCHAR* sx, TCHAR* sy, TCHAR* sz, TCHAR* tx, TCHAR* ty, TCHAR* tz, int _targetIndex=-1) {
		setAnim(param, gc, gtype, _targetIndex);
		setSubanims(sx, sy, sz);
		setTargets(tx, ty, tz);
		return *this;
	}

	AnimParam& setAnim(TCHAR* param, IGameControl* gc, IGameControlType gtype, TCHAR* s, TCHAR* t, int _targetIndex=-1) {
		setAnim(param, gc, gtype, _targetIndex);
		setSubanim(s);
		setTarget(t);
		return *this;
	}

	AnimParam& setMapper(PropertyMapper* m) { 
		if (mapper != NULL) delete mapper;
		mapper = m; if (mapper == NULL) mapper = new IdentityMapper(); return *this; 
	}

	AnimParam& setObjectID(TSTR& id) { 
		objectID = id; 
		animID = objectID + TSTR(_T("-")) + paramID;
		return *this; 
	}

	void setTargets(Tab<const TCHAR*> _targets) {
		clearTargets();
		int count = _targets.Count();
		targets.SetCount(count);
		for (int i = 0; i < count; ++i) targets[i] = new TSTR(_targets[i]);
	}

	void setTargets(TCHAR* tx, TCHAR* ty, TCHAR* tz) {
		clearTargets();
		targets.SetCount(3);
		targets[0] = new TSTR(tx);
		targets[1] = new TSTR(ty);
		targets[2] = new TSTR(tz);
	}

	void setTarget(TCHAR* t) {
		clearTargets();
		TSTR* ns = new TSTR(t);
		targets.Append(1, &ns);
	}

	void setSubanims(Tab<const TCHAR*> _subanims)
	{
		clearSubanims();
		int count = _subanims.Count();
		subanims.SetCount(count);
		TSTR prefix = objectID + TSTR(_T("-")) + paramID + TSTR(_T("-"));
		if (targetIndex != -1) prefix.printf("%s%d-", prefix.data(), targetIndex); 
		for (int i = 0; i < count; ++i) subanims[i] = new TSTR(prefix + _subanims[i]);
	}

	void setSubanims(TCHAR* sx, TCHAR* sy, TCHAR* sz) {
		clearSubanims(); 
		TSTR prefix = objectID + TSTR(_T("-")) + paramID + TSTR(_T("-"));
		if (targetIndex != -1) prefix.printf("%s%d-", prefix.data(), targetIndex); 
		TSTR* ns[3] = { new TSTR(prefix), new TSTR(prefix), new TSTR(prefix) };
		ns[0]->Append(TSTR(sx)); ns[1]->Append(TSTR(sy)); ns[2]->Append(TSTR(sz)); 
		subanims.Append(3, (TSTR**)&ns);
	}
	
	void setSubanim(TCHAR* s) {
		clearSubanims();
		TSTR* ns = new TSTR(objectID + TSTR(_T("-")) + paramID + TSTR(_T("-")));
		if (targetIndex != -1) ns->printf("%s%d-", ns->data(), targetIndex); 
		ns->append(TSTR(s));
		subanims.Append(1, &ns);
	}

	void clearTargets() {
		for (int i = 0; i < targets.Count(); i++)
			delete targets[i];
		targets.SetCount(0);
	}

	void clearSubanims() {
		for (int i = 0; i < subanims.Count(); i++)
			delete subanims[i];
		subanims.SetCount(0);
	}

	bool isRelative() { return relative; }
	void setRelative(bool r) { relative = r; }
};

#endif // _ANIM_PARAM_H_